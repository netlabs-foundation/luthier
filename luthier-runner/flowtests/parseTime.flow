import scala.concurrent.duration._
import uy.com.netlabs.luthier.endpoint._, stream._, Tcp._, http._
import dispatch.{Http=>_, _}
import scala.util._, scala.concurrent.duration._
import scala.tools.nsc.interpreter.IR

//introduce top level class
interpreter.interpret("case class Entry(date: String, user: String, activity: String, project: String, issue: String, tracker: String, subject: String, hours: Double, comment: String)")
new Flow("parser")(Server(4000, 1024)) {

  val certsPath = scala.util.Properties.userHome + "/nl-certs/"  // YOUR CERT PATH HERE
  val user = scala.util.Properties.userName // YOUR KEYS NAME HERE
  val sslContext = SSLContext(
    SslKeys(s"${certsPath}${user}.netlabs.com.uy.der"), SslCerts(s"${certsPath}${user}.netlabs.com.uy.crt"),
    SslCerts(s"${certsPath}nlca.netlabs.com.uy.crt"), sslProtocol = "TLSv1.2")

  //redmine endpoint generator
  def redmine[ResultType] = Http[ResultType](httpClientConfig = ClientConfig(sslContext = sslContext))

  logic {client =>
    val postParams = Map("username"->"user", "password"->"pass")

    val cvs = redmine[String].ask(client map (_ =>
      (url("https://redmine.netlabs.com.uy/login").setFollowRedirects(true) << postParams,
       new OkFunctionHandler(as.String)))
    ) flatMap {res =>
      res.header.swap //swap headers to send the cookies we received
      redmine[String].ask(res map (_ => (url("https://redmine.netlabs.com.uy/time_entries.csv"),
                                         new OkFunctionHandler(as.String)))).map {cvsData =>
        interpreter.beQuietDuring {
          require(interpreter.bind("cvsData", cvsData.payload) == IR.Success)
          require(
          interpreter.interpret("""
            import scala.collection.JavaConverters._
            val rows = new au.com.bytecode.opencsv.CSVReader(new java.io.StringReader(cvsData)).readAll()
            val entries = rows.asScala.drop(1).par.map {parts =>
              Entry(parts(0), parts(1), parts(2), parts(3), parts(4), parts(5), parts(6), parts(7).toDouble, parts(8))
            }.seq
          """) == IR.Success)
        }
      }
    }
    client.payload.conn.write(java.nio.ByteBuffer wrap ">".getBytes)
    new Flow("clientHandler-" + client.payload)(Handler(client, consumers.lines(),
                                                        ReadWaitAction.ReadValueData(30000, "---"))) {
      logic {m =>
        m.payload match {
          case "---" =>
            closeClient(client)
          case req =>
            if (!cvs.isCompleted) client.payload.conn.write(java.nio.ByteBuffer wrap "Processing request\n".getBytes)
            cvs.onComplete {
              case Success(entries) =>
                val res = interpreter.interpret(req) match {
                  case IR.Success =>
                    val res = interpreter.lastRequest.getEvalTyped[Seq[_]].map(_.map(_.toString).mkString("\n") + "\n>").getOrElse("Query failed\n")
                    client.payload.conn.write(java.nio.ByteBuffer wrap res.getBytes)
                  case other => client.payload.conn.write(java.nio.ByteBuffer wrap "Query failed\n".getBytes)
                }
              case Failure(err) => closeClient(client)
            }
        }
      }
    }
  }
}
